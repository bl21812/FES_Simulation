from helpers.MuscleVelocity import getMuscleVelocity
from helpers.Regression import modelEval

ankleInertia = 90

# Wrapper for the system of state-space equations.
def model(x, muscles, forceLengthRegressionModel, forceVelocityRegressionModel, angleTorqueRegressionModel):
  '''
  @param: x: state vector [ankle angle, angular velocity, muscle normalized CE lengths...]
  @param muscles: list of HillTypeMuscleModel objs. the order corresponds to the muscle normalized CE lengths from x at index 2 onwards
  '''
  theta, angularVelocity = x[:2]
  normMuscleLengths = x[2:]

  assert len(muscles) == len(normMuscleLengths)

  muscleNormLengthDerivs = [] 
  muscleTorques = []
  for muscle, normMuscleLength in zip(muscles, normMuscleLengths):
    # first find the params to find the length derivatives
    muscleTendonLength = muscle.muscleTendonLength(theta)
    normTendonLength = muscle.normTendonLength(muscleTendonLength, normMuscleLength)
    lengthDeriv = getMuscleVelocity(
                    a = muscle.activationModel.getNextActivation(theta),
                    lm = normMuscleLength, 
                    lt = normTendonLength, 
                    alpha = muscle.pennation, 
                    forceLengthRegressionModel = forceLengthRegressionModel, 
                    forceVelocityRegressionModel = forceVelocityRegressionModel
                  )
    muscleNormLengthDerivs.append(lengthDeriv)

    # also calculate the torques generated by each muscle
    torque = muscle.momentArm * muscle.getForce(muscleTendonLength, normMuscleLength)
    muscleTorques.append(torque)

  angularVelocityDeriv = -1 * modelEval(theta, angleTorqueRegressionModel.coef_, angleTorqueRegressionModel.intercept_, 0.55)/ankleInertia
  
  return [angularVelocity, angularVelocityDeriv] + muscleNormLengthDerivs
