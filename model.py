import math
from helpers.MuscleVelocity import getMuscleVelocity
from helpers.regression import modelEval
from helpers.GravityMoment import gravityMoment

ankleInertia = 90
mass = 75 # kg

# Wrapper for the system of state-space equations.
def model(x, muscles, models, t):
  '''
  @param: x: state vector [ankle angle, angular velocity, muscle normalized CE lengths...]
  @param muscles: list of HillTypeMuscleModel objs. the order corresponds to the muscle normalized CE lengths from x at index 2 onwards
  @param models: list of regression models used to make predictions in the order: forceLengthRegressionModel, forceVelocityRegressionModel, angleTorqueRegressionModel
  @param t: time step to find the activation
  '''
  forceLengthRegressionModel, forceVelocityRegressionModel, angleTorqueRegressionModel = models
  
  theta, angularVelocity = x[:2]
  normMuscleLengths = x[2:]

  assert len(muscles) == len(normMuscleLengths)

  muscleNormLengthDerivs = [] 
  muscleTorques = 0
  for muscle, normMuscleLength in zip(muscles, normMuscleLengths):
    # first find the params to find the length derivatives
    muscleTendonLength = muscle.muscleTendonLength(theta)
    normTendonLength = muscle.normTendonLength(muscleTendonLength, normMuscleLength)
    lengthDeriv = getMuscleVelocity(
                    a = muscle.activationModel.getNextActivation(theta, t),
                    lm = normMuscleLength, 
                    lt = normTendonLength, 
                    alpha = muscle.pennation, 
                    forceLengthRegressionModel = forceLengthRegressionModel, 
                    forceVelocityRegressionModel = forceVelocityRegressionModel
                  )
    muscleNormLengthDerivs.append(lengthDeriv)

    # also calculate the torques generated by each muscle
    torque = muscle.momentArm * muscle.getForce(muscleTendonLength, normMuscleLength)
    muscleTorques += torque

  # angularVelocityDeriv = -1 * modelEval(theta, angleTorqueRegressionModel.coef_, angleTorqueRegressionModel.intercept_, 0.023)/ankleInertia
  # cycleLength = 2
  # linearPortion = 0.1
  # totalTorque = ankleTorqueLinear(theta) if (t % cycleLength)/cycleLength <= linearPortion * cycleLength else ankleTorque(theta)
  # angularVelocityDeriv = mass * ankleTorque(theta)/ankleInertia
  # angularVelocityDeriv = mass * totalTorque/ankleInertia

  # angularVelocityDeriv = (-muscleTorques + dComAnkle * ankleMass * g * math.sin(math.pi/2 - theta))/ankleInertia
  angularVelocityDeriv = (-muscleTorques + gravityMoment(theta, mass))/ankleInertia
  
  return [angularVelocity, angularVelocityDeriv] + muscleNormLengthDerivs

def ankleTorque(theta): 
  a = 531.6061154105003
  b = -1254.1471652109215
  c = 1106.9915190120637
  d = -433.2372975668462
  e = 63.42285178599744

  model = lambda x: a + b*x + c*x**2 + d*x**3 + e*x**4
  if theta < math.radians(70):
    return model(math.radians(70))
  elif theta > math.radians(110):
    return model(math.radians(110))
    
  return model(theta)

def ankleTorqueLinear(theta): 
  a = 4.2337
  b = -2.1987

  model = lambda x: a + b*x
  return model(theta)